<?php

/*
 * This file is part of the symfony package.
 * (c) 2004-2006 Fabien Potencier <fabien.potencier@symfony-project.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/*
 * NOTE: Symfony tone support is based on
 * Garden (http://garden.tigris.org), Copyright 2006 Tomas Varaneckas
 * which is originally licensed under the Apache License, Version 2.0
 * You may obtain a copy of that license at http://www.apache.org/licenses/LICENSE-2.0
 *
 * However, by totally refactoring it to symfony needs it is now shipped
 * with symfony under the license you can find in the LICENSE
 * file that was distributed with this source code.
 *
 * If you have any questions about the symfony tone implementation,
 * please consider to not contact the original author of Garden
 * but ask on the symfony mailing list.
 */

/**
 * sfToneConfigHandler allows you to configure symfony tones.
 *
 * @package    symfony
 * @subpackage config
 * @author     Matthias Nothhaft <matthias.nothhaft@googlemail.com>
 * @version    $Id$
 */
class sfToneConfigHandler extends sfYamlConfigHandler
{
  /**
   * Holds the default tone definition.
   * @var array
   */
  protected $defaultTone = array(
    'id' => '',
    'aliases' => array(),
    'description' => '',
    'constructor_args' => array(),
    'properties' => array(),
    'parent' => false,
    'class' => false,
    'file' => false,
    'abstract' => false,
    'singleton' => false,
    'lazy_init' => true, // we should swap the logic and rename it to 'preload'
    'preload_config_condition' => false, // if set it will only preload if sfConfig::get($condition) is true
    'depends_on' => array(),
    'init_method' => false,
    'destroy_method' => false,
    'factory_method' => false,
    'factory_tone' => false
  );

  /**
   * Executes this configuration handler.
   *
   * @param array   An array of absolute filesystem path to a configuration file
   * @return string Data to be written to a cache file
   */
  public function execute($configFiles)
  {
    // parse the yaml
    $this->myConfig = $this->mergeEnvironment($this->parseYamls($configFiles));

    if (empty($this->myConfig['aliases']) || !is_array($this->myConfig['aliases']))
    {
      $this->myConfig['aliases'] = array();
    }

    $this->toneDefinitions = array();

    foreach ($this->myConfig as $id => $toneDef)
    {
      if ($id === 'aliases') continue;

      $this->toneDefinitions[$id] = $this->parseToneDefinition($id, $toneDef);
    }


    // compile data
    $retval = '';
    $retval = "<?php\n".
              "// auto-generated by sfToneConfigHandler\n".
              "// date: %s\n\n";

    $retval = sprintf($retval, date('Y/m/d H:i:s'));
    $retval .= "return " . var_export($this->toneDefinitions, true) . ";\n";

    return $retval;
  }

  /**
   * Parses one single tone definition.
   *
   * @param string Name of the tone to parse.
   * @return array Well formed tone definition for use with the factory.
   */
  protected function parseToneDefinition($name, $toneDef)
  {
    if (!empty($this->toneDefinitions[$name]))
    {
      return $this->toneDefinitions[$name];
    }

    // first we need the default values
    $def = $this->defaultTone;

    // we have to add the id here as the definition is passed around
    // in the tone factory while it needs to know what it is
    $def['id'] = $name;

    if (!empty($toneDef['description']))
    {
      $def['description'] = $toneDef['description'];
    }

    $def['aliases'] = $this->getAliases($name);

    if (!empty($toneDef['parent']))
    {
      // fill our definition with those of the parent
      $def = $this->inheritDefinitionFrom($def, $toneDef['parent'], $name);
      $def['parent'] = $toneDef['parent'];
    }
    else
    {
      $def['parent'] = false;
    }

    // overwrite remaining values only if set (to preserve existing parent values)

    if (!empty($toneDef['constructor_args']) && is_array($toneDef['constructor_args']))
    {
      $def['constructor_args'] = $toneDef['constructor_args'];
    }

    if (!empty($toneDef['properties']) && is_array($toneDef['properties']))
    {
      $def['properties'] = $toneDef['properties'];
    }

    if (!empty($toneDef['class']))
    {
      $def['class'] = $toneDef['class'];
    }

    if (!empty($toneDef['file']))
    {
      $def['file'] = $toneDef['file'];
    }

    if (isset($toneDef['abstract']))
    {
      $def['abstract'] = (bool) $toneDef['abstract'];
    }

    if (isset($toneDef['singleton']))
    {
      $def['singleton'] = (bool) $toneDef['singleton'];
    }

    if (isset($toneDef['lazy_init']))
    {
      $def['lazy_init'] = $toneDef['lazy_init'];
    }

    if (!empty($toneDef['preload_config_condition']))
    {
      $def['preload_config_condition'] = $toneDef['preload_config_condition'];
    }

    if (!empty($toneDef['depends_on']))
    {
      if (!is_array($toneDef['depends_on']))
      {
        throw new sfConfigurationException("Field 'depends_on' must be of type array in definition of tone " . $name);
      }
      // check dependencies
      foreach ($toneDef['depends_on'] as $dep)
      {
        $depAlias = $this->getAlias($dep);
        if (empty($this->myConfig[$depAlias]))
        {
          throw new sfConfigurationException('Unable to resolve dependency on ' . $dep . ' in definition of tone ' . $name);
        }
      }
      $def['depends_on'] = $toneDef['depends_on'];
    }

    $def['init_method'] = !empty($toneDef['init_method']) ? $toneDef['init_method'] : $def['init_method'];
    $def['destroy_method'] = !empty($toneDef['destroy_method']) ? $toneDef['destroy_method'] : $def['destroy_method'];
    $def['factory_method'] = !empty($toneDef['factory_method']) ? $toneDef['factory_method'] : $def['factory_method'];
    $def['factory_tone'] = !empty($toneDef['factory_tone']) ? $toneDef['factory_tone'] : $def['factory_tone'];

    return $def;
  }

  protected function getAliases($name)
  {
    $aliases = array();

    foreach ($this->myConfig['aliases'] as $alias => $id)
    {
      if ($id === $name)
      {
        $aliases[] = $alias;
      }
    }

    return $aliases;
  }

  protected function getAlias($alias)
  {
    return !empty($this->myConfig['aliases'][$alias]) ? $this->myConfig['aliases'][$alias] : $alias;
  }

  /**
   * Merges parent definition with child definition.
   *
   * @param array  Child definition
   * @param string Parent name
   * @param string Child name
   * @return array Merged definition of child and parent
   */
  protected function inheritDefinitionFrom($def, $parent, $child)
  {
    if (empty($this->myConfig[$parent]))
    {
      throw new sfConfigurationException('Unknown tone parent ' . $parent . ' in definition of tone ' . $child);
    }

    if (empty($this->toneDefinitions[$parent]))
    {
      $this->toneDefinitions[$parent] = $this->parseToneDefinition($parent, $this->myConfig[$parent]);
    }

    $parentDef = $this->toneDefinitions[$parent];

    // only inherit some values
    $inheritedDef = $def;
    $inheritedDef['constructor_args'] = $parentDef['constructor_args'];
    $inheritedDef['properties'] = $parentDef['properties'];

    return $inheritedDef;
  }

  /**
   * Merges default, all and current environment configurations.
   *
   * @param array The main configuratino array
   * @return array The merged configuration
   */
  protected function mergeEnvironment($config)
  {
    return sfToolkit::arrayDeepMerge(
      isset($config['default']) && is_array($config['default']) ? $config['default'] : array(),
      isset($config['all']) && is_array($config['all']) ? $config['all'] : array(),
      isset($config[sfConfig::get('sf_environment')]) && is_array($config[sfConfig::get('sf_environment')]) ? $config[sfConfig::get('sf_environment')] : array()
    );
  }

}
